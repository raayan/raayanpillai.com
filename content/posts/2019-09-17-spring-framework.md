---
date: "2019-09-17T00:00:00Z"
categories: software
tags:
- spring
- java
- frameworks
title: The Spring Framework
---

## What is it?
An application development framework based on Inversion-of-Control (IOC). 
Specifically, the **control** that we are **inverting** is the creation and setting of an object’s dependencies.
It is an IOC container at heart, but offers much more.
*Managed objects* or *beans*, are objects created and maintained by the container. 
- Lightweight: can use just pieces of it and still reap benefits
- Flexible: various ways to use Spring and achieve the same outcome
- Less Code: it attempts to cut down on boilerplate and cruft
- Loose Coupling: loose coupling is promoted when using the framework 

Spring, as an IOC container, tries to instantiate beans eagerly and loads services lazily. This means that all the beans (managed objects) are made first, then the services that depend on them will startup.

### Lazy vs Eager
Lazy, in a Spring context, usually means that the thing will be done (initializing a bean) only when asked.
Eager, in a Spring context, usually means that the thing will be done before it is asked (usually on application startup). 
In Spring, bean initialization is eager by default, this means that the Spring IOC container will initialize all singleton-beans on startup.

When it comes to bean initialization, lazy means the bean will only be initialized when it **needs** to. This offers a speed-up on startup, but if there are issues with this bean when it gets initialized your program will crash. Having your program crash on startup is better than at some random point in the future because you’ll usually be able to address it before something bad has happened.  

## Wait! What the hell does IOC DI look like?
Look no further than this chunk of code

```java
public class ManualEyeOhSeeApplication { // This is a joke EyeOhSee = IOC
	public static void main(String args) {
		//// No dependency injection
		// Both components depend on SomeDependency, and they each instantiate one
		FirstComponent firstComponentA = new FirstComponent();
		SecondComponent secondComponentA = new SecondComponent();

		//// Manual dependency injection
		// Here both components depend on the same SomeDependency
		// The control over creation of their dependencies has been inverted 
		SomeDependency someDependency = new SomeDependency();
		FirstComponent firstComponent = new FirstComponent(someDependency);
		SecondComponent SecondComponent = new SecondComponent(someDependency);
	}
}

class FirstComponent {
	private SomeDependency someDependency;
	
	public FirstComponent() {
		this.someDependency = new SomeDependency();
	}

	public FirstComponent(SomeDependency someDependency) {
		this.someDependency = someDependency;
	}
}

class SecondComponent {
	private SomeDependency someDependency;
	
	public SecondComponent() {
		this.someDependency = new SomeDependency();
	}

	public SecondComponent(SomeDependency someDependency) {
		this.someDependency = someDependency;
	}
}
```

FirstComponentA and SecondComponentA both are initialized with their default constructors which instantiate a *new* SomeDependency.
This means each of them will have *their own* SomeDependency.
FirstComponentB and SecondComponentB are initialized with a SomeDependency passed into their constructor.
Looking at the code for this you can see that they share the *same* instance of SomeDependency and this is achieved with *dependency-injection*.

## Spring? SpringBoot? Poland Spring?
Spring is the framework at-large and Spring Boot is specific style of using Spring that is focused on reducing boilerplate, hence boot(strap).
SpringBoot cuts down a lot of configuration so you can get something built quicker. 

## What is Dependency Injection (DI)?
Software design pattern that implements the IOC pattern for resolving dependencies. 
DI separates the creation of dependencies from the dependent’s core code.
Using DI promotes: loose coupling, single-responsibility, and a 

## How can we use DI in Spring?
There are three main ways of using *dependency-injection* in Spring

### Constructor
Generally preferred, what is happening is more apparent, and dependencies can be easily generated by JavaDocs.

```java
private SomeBean someBean;
private SomeOtherBean someOtherBean;

@Autowired // In more recent Spring @Autowired is implicit, when their is one constructor
public SomeClass(SomeBean someBean) {
	this.someBean = someBean;
}

@Autowired
public SomeClass(@Qualifier(“namedBean”) SomeOtherBean someOtherBean) {
	this.someOtherBean = someOtherBean;
}
```

### Setter

Generally, setter-based DI is used after invoking a no-argument constructor or no-argument factor method.
If applicable, you can use constructor-based DI for mandatory dependencies and setter-based DI for optional dependencies.

```java
private SomeBean someBean;

@Autowired
public void setSomeBean(SomeBean someBean) {
	this.someBean = someBean;
}
```

### Field

The WOAT (Worse-Of-All-Time) in Spring DI. This should rarely be used, many novice Spring practitioners will use/overuse field-based DI since it looks super clean and is easy. In the Spring framework, field-based DI is achieved by the unholy black-majik known as *reflection*. This has a higher performance-cost than setter-based or constructor-based injection. 

A nice visual way to know you’re screwing up the **single-responsibility principle** (SRP), is if you use constructor-based injection and your constructor is a massive beast. With field-based injection you don’t get this visual-cue. 

```java
@Autowired
private SomeBean someBean;
```

## What is Autowiring?
Autowiring is a means of DI, where you let Spring decide which bean to inject.
### Autowiring cannot be ambiguous!
If there are two beans of type `SomeBean` and you are Autowiring SomeBean, Spring will not be able to figure out which one to use. You would then use the `@Qualifier` annotation to clear that up.

```java
public abstract class Bike { ... }
@Component public class SlowBike extends Bike { ... }
@Component public class FastBike extends Bike { ... }

public class BikeRackThatHoldsOneBike {
	private Bike bike;

	@Autowired
	public BikeRackThatHoldsOneBike(Bike bike) {
		this.bike = bike;
	}
}
```

In the above example, BikeRackThatHoldsOneBike won’t be able to inject its Bike dependency since two beans in the context match the type of Bike (SlowBike and FastBike). Deleting either SlowBike or FastBike will make it so the @Autowire finds only one matching bean. If you changed the constructor’s Bike parameter to FastBike or SlowBike, Spring would be able to inject the dependency. You can also use @Qualifier or other specification means to tell it which bean to use.

### Modes of Autowiring
#### Type
Spring will use the class type to figure out which bean to use.
#### Constructor
Spring will use the constructor to inject the dependency.
#### Name
Spring will use the name of variable to inject the dependency.


## Property Injection
Properties, in a Spring context, are usually immutable values.

What to do if you want to get some `String` from your configuration files? What if you want to inject into a primitive? Slapping an `@Autowire` on the former would not give you what you’re looking for, and doing that to the latter straight up would not work.

What if I use primitive wrappers like `Float`, fine but this is the same thing as putting an `@Autowire` on a `String`. Spring would have trouble finding the right bean to inject. Loading your configurations into your application and then providing them as beans seems a bit janky as well. 

To inject configurations you can use `@Value(“${path.to.props}”)`. You can use it anywhere you’d Autowire, on constructors, methods or fields. 

```java
@Value(“${me.name}”)
private String myName;
private String yourName;
private String tonyName;

public SomeClass(@Value(“${you.name}”) yourName( {
	this.yourName = yourName;
}

public void setTonyName(@Value(“${tony.name}”) tonyName) {
	this.tonyName = tonyName;
}
```

## What makes a SpringBoot application SpringBoot?
The @SpringBootApplication annotation on your main application’s class, is where the magic happens. Breaking this annotation down shows us what SpringBoot really does.

The @SpringBootApplication annotation is considered a meta-annotation, meaning: it is an annotation composed of other annotations. It is made up of three annotations: @SpringBootConfiguration, @ComponentScan and @EnableAutoConfiguration.

### SpringBootConfiguration
The @SpringBootConfiguration annotation is just a specialization of Spring’s @Configuration annotation.

### EnableAutoConfiguration
The @EnableAutoConfiguration annotation is what enables Spring’s intelligent and easy configuration.
After the @ComponentScan runs, the @EnableAutoConfiguration will try get the of the beans for the context.
In more advanced applications or anything production-grade you’d want to configure the AutoConfiguration (sounds fun).

## ComponentScan
Slapping a @ComponentScan on top of a class means that it will scan the whole package that this class sits in, including sub-packages. ComponentScan will not scan packages parallel to it.
If your main application class is annotated with a @ComponentScan (or implicitly with a @SpringBootApplication) and is left at the same level of all your other packages, the @ComponentScan will be able to pick up everything in your project.

Often times people get confused when they move their main application class, having @SpringBootApplication, into some sub-package and all their precious Autowiring gets ruined.

```bash
.
├── com.raayan.one # @ComponentScan
│	├── com.raayan.one.alpha # All beans picked up
│	└── com.raayan.one.bravo # All beans picked up
└── com.raayan.two # Not scanned 
```

The @Import annotation can be used to specify the classes you want to be picked up instead of scanning the whole package.

## Component
The @Component annotation tells Spring, when it’s scanning for components, that this is a component be instantiated. There can only be one instance of this specific type.

### Component vs Bean
By nature of annotating the class with @Component you should see that Spring can’t pick up more than one of these. 
However, you could annotate multiple methods that return the same class with the @Bean annotation.

```java
public class Person {
	String name;
	public Person(String name) {
		this.name = name;
	}
}

@Component
public class OnlyPerson extends Person {
	public OnlyPerson(String name) {
		super(name);
	}
}

@Configuration
public class PeopleConfiguration {
	@Bean
	public Person personJeff() {
		return new Person(“Jeff”);
	}

	@Bean
	public Person personBob() {
		return new Person(“Bob”);
	}
}
```

In this example, OnlyPerson is a @Component, which means there will only be one OnlyPerson initialized in our application by Spring.

When Spring scans PeopleConfiguration, both Person beans will be picked up, and there will be two beans of type People, named personBob and personJeff, instantiaed by Spring.

### Specialized Components
#### Service
The @Service annotation indicates that this component is a *service* which generally means, in *Domain-Driven Design*, that it is an operation that can stand-alone and belongs to no other thing. Basically, do not use services as dependencies.

#### Repository
The @Repository annotation indicates that this component is a *repository* which, defined by *Domain-Drive Design*, is something that emulates a collection of objects and provides storage, retrieval and search. This could interface with a database or some REST interface. In general any means of retrieving and manipulating data outside of the application’s state.

#### Controller
The @Controller annotation indicates that this component is a *controller*, usually a web-controller. Usually components of this specialization are used with the @RequestMapping annotation to have methods respond to requests.

##### RestController
The @RestController annotation is a specialized @Controller annotation. It combines @Controller and @ResponseBody so you don’t have to annotate every method returning a response with @ResponseBody. 

```java
@Controller
@RequestMapping(“old”)
public class OldSchoolController {
	@GetMapping(“hey”)
	public @ResponseBody String getHey() {
		return “hey”;
	}
}

@RestController
@RequestMapping(“hip”)
public class HipNewRestController {
	@GetMapping(“hey”)
	public String getHey() {
		return “hey”;
	}
}
```

In this example both “/old/hey” and “/hip/hey” do the same thing but you don’t have to specify @ResponseBody, it is implicit.

###### ResponseBody
The @ResponseBody annotation tells Spring to automatically serialize the return object into the body of an HttpResponse.

###### RequestMapping
The @RequestMapping method specifies the path of an HTTP request. If its on the parent class level of a method all child @RequestMapping annotations are prefixed with the parent’s path.
The @GetMapping, @PostMapping are all short hands of the relevant @RequestMapping.
That means `@RequestMapping(value = “hello”, method = RequestMethod.GET)` and `@GetMapping(value = “hello”)` are equivalent.

#### Configuration
The @Configuration annotation indicates that this component is a *configuration*, which means that this class provides some @Bean annotated methods, providing beans to the context. 
The @Configuration is unique, to the other specialized @Component annotations I’ve mentioned. Classes annotated with @Configuration do not get instantiated as beans themselves. 

```java
@Configuration
public class SomeConfiguration {
	@Bean
	public SomeBean juicyBeanOne() {
		return new SomeBean();
	}

	@Bean
	public SomeBean juicyBeanTwo() {
		return new SomeBean();
	}
}
```

In this example, there will be no bean of type SomeConfiguration in the application context that scans this configuration.

## Bean
The @Bean annotation on a method provides a component to the application context. 
When a @ComponentScan executes, it will see @Bean and say “Oh cool, a bean!” Then it will call this method and the return will be added to the context as a bean. If no name is specified, the method name will be the bean’s name.

```java
@Configuration
public class SomeConfiguration {
	@Bean
	public SomeBean methodNamedBean() {
		return new SomeBean();
	}

	@Bean(name = “explicitlyNamedBean”)
	public SomeBean ignoreThisMethodName() {
		return new SomeBean();
	}
}
```

In this example, the first method annotated with @Bean will produce a bean of type SomeBean named “methodNamedBean” and the second will produce a bean of type SomeBean named “explicitlyNamedBean” to the context.

## Testing
When using JUnit, we can use the @RunWith annotation to tell the test to use the SpringBootRunner or SpringJUnit4Runner to startup with the application context. This startups the **whole** application context, meaning the AutoConfiguration will run and all those beans will get pulled in. This is fine if you’re integration testing or need the whole context, but if you’re unit testing this will be quite bulky.

You’ll want to specify smaller contexts. This way you can startup the **relevant** beans for the test and **nothing** more. This can be done be done using the `load(C)` method, C being a class annotated with @Configuration. The test can also be annotated with @ContextConfiguration and you can provide the configuration class (classes annotated with @Configuration) there.

Why startup the database related context when unit testing the rest controller? Specify contexts and you will speed up your test iteration.

```java
@RunWith(SpringRunner.class) // Same as using SpringJUnit4ClassRunner.class
@ContextConfiguration(classes = { SomeComponentConfiguration.class }, loader = AnnotationConfigContextLoader.class)
public class SomeComponentTest {
	@Autowired // Assuming SomeBean is provided in SomeComponentConfiguration
	public SomeBean someBean;
}
```

If using SprintBoot and some context is not specified (using @ContextConfiguration or something else), if possible, the test will find the @SpringBootConfiguration annotated file and use that. This would result in your whole application’s context starting up. As mentioned earlier, this may take unnecessary time. Test writing is hard enough, why make it harder?
